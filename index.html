<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cockney Rhyming Slang Translator</title>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; margin: 2em; }
    textarea, button { width: 100%; font-size: 1.1em; margin-top: 1em; padding: 0.5em; }
    .output { margin-top: 1.5em; padding: 1em; background: #f0f0f0; border-radius: 5px; }
  </style>
</head>
<body>
  <h1>Cockney Translator</h1>
  <p>Type a sentence in English to see the Cockney rhyming slang translation:</p>
  <textarea id="inputText" rows="4" placeholder="Enter your sentence..."></textarea>
  <button onclick="translate()">Translate</button>
  <div id="variantPanel" class="panel" hidden>
  <strong>Pick your slang variants</strong>
  <div id="choices"></div>
</div>

<div class="panel">
  <strong>Output</strong>
  <div id="output" class="output"></div>
</div>

<script>
  // --- CONFIG ---
  const VARIANTS_URL = "https://cockney-agent-2.onrender.com/api/slang_variants"; // preferred
  const FALLBACK_URL = "https://cockney-agent-2.onrender.com/api/slang";          // fallback if variants not available

  let variantsMap = {};   // meaning -> [variants]
  let selectionMap = {};  // meaning -> chosen variant string

  // Load variants (or fallback to single variant per meaning)
  async function loadDictionary() {
    try {
      const res = await fetch(VARIANTS_URL, { cache: 'no-store' });
      if (!res.ok) throw new Error('variants endpoint not available');
      variantsMap = await res.json();
    } catch (e) {
      const res = await fetch(FALLBACK_URL, { cache: 'no-store' });
      const single = await res.json();
      // Upgrade to variant arrays by creating [phrase, shortened]
      variantsMap = Object.fromEntries(Object.entries(single).map(([meaning, phrase]) => {
        const parts = phrase.split(/\s+/);
        const shortened = parts.length > 1 ? parts.slice(0, -1).join(' ') : phrase;
        const arr = [phrase];
        if (shortened && shortened.length >= 3 && shortened !== phrase) arr.push(shortened);
        return [meaning, arr];
      }));
    }
  }

  // Tokenize while keeping boundaries (spaces/punct)
  function tokenize(text) { return text.split(/(\b)/); }
  function cleanWord(tok) { return tok.toLowerCase().replace(/[^a-z']/g, ""); }

  // Build the live choices UI for any meanings found in the input
  function buildChoices(tokens) {
    const container = document.getElementById('choices');
    container.innerHTML = '';

    const seen = new Set();
    const matches = [];
    tokens.forEach((t) => {
      const key = cleanWord(t);
      if (key && variantsMap[key] && !seen.has(key)) {
        seen.add(key);
        matches.push({ meaning: key, variants: variantsMap[key] });
      }
    });

    const panel = document.getElementById('variantPanel');
    panel.hidden = matches.length === 0;

    matches.forEach(({ meaning, variants }) => {
      const row = document.createElement('div');
      row.className = 'choice';

      const label = document.createElement('label');
      label.textContent = meaning;
      label.htmlFor = `sel-${meaning}`;

      const note = document.createElement('small');
      note.textContent = 'choose a rhyme';

      const select = document.createElement('select');
      select.id = `sel-${meaning}`;
      variants.forEach((v) => {
        const opt = document.createElement('option');
        opt.value = v;
        opt.textContent = v;
        select.appendChild(opt);
      });
      // keep previous selection if user picked one
      if (selectionMap[meaning]) select.value = selectionMap[meaning];
      else selectionMap[meaning] = variants[0];

      select.addEventListener('change', () => {
        selectionMap[meaning] = select.value;
        renderOutput();
      });

      const left = document.createElement('div');
      left.style.display = 'flex';
      left.style.flexDirection = 'column';
      left.appendChild(label);
      left.appendChild(note);

      row.appendChild(left);
      row.appendChild(select);
      container.appendChild(row);
    });
  }

  function preserveCase(originalToken, replacement) {
    const wordOnly = originalToken.match(/[A-Za-z']+/);
    if (!wordOnly) return replacement;
    const w = wordOnly[0];
    if (w[0] === w[0].toUpperCase()) {
      return replacement.charAt(0).toUpperCase() + replacement.slice(1);
    }
    return replacement;
  }

  function renderOutput() {
    const text = document.getElementById('inputText').value;
    const tokens = tokenize(text);
    const out = tokens.map(tok => {
      const key = cleanWord(tok);
      if (key && variantsMap[key]) {
        const chosen = selectionMap[key] || variantsMap[key][0];
        return preserveCase(tok, chosen);
      }
      return tok;
    }).join('');
    document.getElementById('output').textContent = out;
  }

  async function init() {
    await loadDictionary();
    const input = document.getElementById('inputText');
    const btn = document.getElementById('translateBtn');

    const recompute = () => {
      const tokens = tokenize(input.value);
      buildChoices(tokens);
      renderOutput();
    };

    input.addEventListener('input', recompute);
    btn.addEventListener('click', recompute);

    recompute(); // initial
  }

  init();
</script>
</body>
</html>