<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Cockney Rhyming Slang Translator</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="theme-color" content="#111111" />
  <style>
    :root { color-scheme: light dark; }
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; margin: 16px; line-height: 1.35; }
    h1 { font-size: 1.25rem; margin: 0 0 8px; }
    p.hint { color: #666; margin: 0 0 12px; }
    textarea { width: 100%; font-size: 16px; padding: 12px; border-radius: 10px; border: 1px solid #ddd; outline: none; }
    .row { display:flex; gap: 12px; align-items:center; margin-top: 10px; }
    .btn { appearance:none; border:0; border-radius:10px; padding:12px 14px; font-size:16px; background:#111; color:#fff; width:100%; }
    .panel { margin-top: 14px; padding: 12px; background:#f5f5f7; border-radius: 12px; }
    .choice { display:flex; align-items:center; justify-content:space-between; gap: 10px; padding:10px 0; border-bottom:1px solid #ececec; }
    .choice:last-child { border-bottom:none; }
    .choice label { font-weight:600; min-width: 110px; text-transform: lowercase; }
    .choice small { color:#666; }
    select { flex:1; font-size: 16px; padding:10px; border-radius:10px; border:1px solid #ddd; background:#fff; }
    .output { white-space: pre-wrap; margin-top: 8px; background:#fafafa; border:1px solid #eee; border-radius:12px; padding:12px; min-height: 64px; font-size: 16px; }
    footer { margin-top: 14px; font-size: 12px; color:#888; text-align:center; }
    @media (hover:hover) { .btn:hover { opacity:.9; } }
  </style>
</head>
<body>
  <h1>Cockney Translator</h1>
  <p class="hint">Type your English sentence. Pick your preferred rhyming variant when prompted. Optimized for iPhone.</p>

  <textarea id="inputText" rows="4" placeholder="Type English here…"></textarea>
  <div class="row">
    <button class="btn" id="translateBtn">Translate</button>
  </div>

  <!-- Variant chooser (appears only when matches are found) -->
  <div id="variantPanel" class="panel" hidden>
    <strong>Pick your slang variants</strong>
    <div id="choices"></div>
  </div>

  <div class="panel">
    <strong>Output</strong>
    <div id="output" class="output"></div>
  </div>

  <footer>© bencockney.rocks</footer>

  <script>
    // ===== CONFIG =====
    // Update these if your backend URL changes:
    const VARIANTS_URL = "https://cockney-agent-2.onrender.com/api/slang_variants"; // preferred endpoint
    const FALLBACK_URL = "https://cockney-agent-2.onrender.com/api/slang";          // fallback if variants not available

    // ===== STATE =====
    let variantsMap = {};  // original: meaning -> [variants]
    let indexMap = {};     // normalizedMeaning -> [variants] (for robust matching)
    let selectionMap = {}; // normalizedMeaning -> chosen variant

    // ===== NORMALIZATION HELPERS =====
    function normalizeMeaningKey(s) {
      if (!s) return "";
      let w = s.toLowerCase();

      // strip parentheses content: "stairs (steps)" -> "stairs"
      w = w.replace(/\(.*?\)/g, " ");

      // remove leading articles: "the wife" -> "wife"
      w = w.replace(/^(the|a|an)\s+/g, "");

      // strip non-letters except apostrophes
      w = w.replace(/[^a-z'\s]/g, " ");

      // collapse spaces
      w = w.replace(/\s+/g, " ").trim();

      // possessive: "wife's" -> "wife"
      w = w.replace(/'s$/, "");

      // simple plural handling
      if (w.endsWith("ies")) w = w.slice(0, -3) + "y"; // babies -> baby
      else if (w.endsWith("es")) w = w.slice(0, -2);   // phones -> phon(e) heuristic
      else if (w.endsWith("s")) w = w.slice(0, -1);    // stairs -> stair

      return w;
    }

    function normalizeToken(tok) {
      // keep apostrophes for possessives before stripping
      const raw = tok.toLowerCase().replace(/[^a-z'\s]/g, "");
      return normalizeMeaningKey(raw);
    }

    // ===== DATA LOAD =====
    async function loadDictionary() {
      try {
        // cache-bust so updates show immediately
        const res = await fetch(VARIANTS_URL + "?t=" + Date.now(), { cache: 'no-store' });
        if (!res.ok) throw new Error('variants endpoint not available');
        variantsMap = await res.json();
      } catch (e) {
        const res = await fetch(FALLBACK_URL + "?t=" + Date.now(), { cache: 'no-store' });
        const single = await res.json();
        // Upgrade to variant arrays by creating [phrase, shortened]
        variantsMap = Object.fromEntries(Object.entries(single).map(([meaning, phrase]) => {
          const parts = (phrase || "").split(/\s+/).filter(Boolean);
          const shortened = parts.length > 1 ? parts.slice(0, -1).join(" ") : phrase;
          const arr = [phrase];
          if (shortened && shortened.length >= 3 && shortened !== phrase) arr.push(shortened);
          return [meaning, arr];
        }));
      }

// Build normalized index for resilient matching
indexMap = {};

function stripOuterQuotes(s) {
  return s.replace(/^["'\s]+|["'\s]+$/g, ""); // trim leading/trailing quotes and spaces
}

// Split meanings on common separators so we index synonyms too
function splitMeaningIntoParts(meaning) {
  // e.g. `"charlie", a street name for cocaine` -> ["charlie", "a street name for cocaine"]
  // e.g. "feet / toes" -> ["feet", "toes"]
  return meaning
    .split(/[,;/]|(?:\s+\bor\b\s+)/gi)  // commas, semicolons, slashes, " or "
    .map(part => stripOuterQuotes(part))
    .filter(Boolean);
}

for (const [meaning, arr] of Object.entries(variantsMap)) {
  const parts = splitMeaningIntoParts(meaning);
  if (parts.length === 0) {
    const norm = normalizeMeaningKey(meaning);
    if (norm && !indexMap[norm]) indexMap[norm] = arr;
    continue;
  }
  for (const part of parts) {
    const norm = normalizeMeaningKey(part);
    if (norm && !indexMap[norm]) indexMap[norm] = arr;
  }
}
    }

    // ===== MATCHING & UI =====
    function tokenize(text) { return text.split(/(\b)/); }

    function getVariantsForToken(tok) {
      const norm = normalizeToken(tok);
      if (norm && indexMap[norm]) return indexMap[norm];

      // last-ditch plural-y fallbacks
      if (indexMap[norm + "s"]) return indexMap[norm + "s"];
      if (norm.endsWith("y") && indexMap[norm.slice(0, -1) + "ies"]) return indexMap[norm.slice(0, -1) + "ies"];
      return null;
    }

    function buildChoices(tokens) {
      const container = document.getElementById("choices");
      container.innerHTML = "";
      const seen = new Set();
      const matches = [];

      tokens.forEach((t) => {
        const variants = getVariantsForToken(t);
        const meaningKey = normalizeToken(t);
        if (variants && meaningKey && !seen.has(meaningKey)) {
          seen.add(meaningKey);
          matches.push({ meaning: meaningKey, variants });
        }
      });

      document.getElementById("variantPanel").hidden = matches.length === 0;

      matches.forEach(({ meaning, variants }) => {
        const row = document.createElement("div");
        row.className = "choice";

        const label = document.createElement("label");
        label.textContent = meaning;
        label.htmlFor = `sel-${meaning}`;

        const note = document.createElement("small");
        note.textContent = "choose a rhyme";

        const select = document.createElement("select");
        select.id = `sel-${meaning}`;
        variants.forEach((v) => {
          const opt = document.createElement("option");
          opt.value = v;
          opt.textContent = v;
          select.appendChild(opt);
        });

        // keep previous selection if user picked one
        if (selectionMap[meaning]) select.value = selectionMap[meaning];
        else selectionMap[meaning] = variants[0];

        select.addEventListener("change", () => {
          selectionMap[meaning] = select.value;
          renderOutput();
        });

        const left = document.createElement("div");
        left.style.display = "flex";
        left.style.flexDirection = "column";
        left.appendChild(label);
        left.appendChild(note);

        row.appendChild(left);
        row.appendChild(select);
        container.appendChild(row);
      });
    }

    function preserveCase(originalToken, replacement) {
      const wordOnly = originalToken.match(/[A-Za-z']+/);
      if (!wordOnly) return replacement;
      const w = wordOnly[0];
      if (w[0] === w[0].toUpperCase()) {
        return replacement.charAt(0).toUpperCase() + replacement.slice(1);
      }
      return replacement;
    }

    function renderOutput() {
      const text = document.getElementById("inputText").value;
      const tokens = tokenize(text);
      const out = tokens.map(tok => {
        const v = getVariantsForToken(tok);
        if (v) {
          const meaning = normalizeToken(tok);
          const chosen = selectionMap[meaning] || v[0];
          return preserveCase(tok, chosen);
        }
        return tok;
      }).join("");
      document.getElementById("output").textContent = out;
    }

    async function init() {
      await loadDictionary();
      const input = document.getElementById("inputText");
      const btn = document.getElementById("translateBtn");

      const recompute = () => {
        const tokens = tokenize(input.value);
        buildChoices(tokens);
        renderOutput();
      };

      input.addEventListener("input", recompute);
      btn.addEventListener("click", recompute);
      recompute(); // initial render
    }

    init();
  </script>
</body>
</html>
