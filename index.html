<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Cockney Rhyming Slang Translator</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="theme-color" content="#111111" />
  <link rel="icon" href="data:," /> <!-- inline favicon to avoid 404 -->
  <style>
    :root { color-scheme: light dark; }
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; margin: 16px; line-height: 1.35; }
    h1 { font-size: 1.25rem; margin: 0 0 8px; }
    p.hint { color: #666; margin: 0 0 12px; }
    textarea { width: 100%; font-size: 16px; padding: 12px; border-radius: 10px; border: 1px solid #ddd; outline: none; }
    .row { display:flex; gap: 12px; align-items:center; margin-top: 10px; }
    .btn { appearance:none; border:0; border-radius:10px; padding:12px 14px; font-size:16px; background:#111; color:#fff; }
    .btn.wide { width:100%; }
    .panel { margin-top: 14px; padding: 12px; background:#f5f5f7; border-radius: 12px; }
    .choice { display:flex; align-items:center; justify-content:space-between; gap:10px; padding:10px 0; border-bottom:1px solid #ececec; }
    .choice:last-child { border-bottom:none; }
    .choice label { font-weight:600; min-width:110px; text-transform: lowercase; }
    .choice small { color:#666; }
    select { flex:1; font-size: 16px; padding:10px; border-radius:10px; border:1px solid #ddd; background:#fff; color: #000;}
   .output { 
  white-space: pre-wrap;
  margin-top: 8px;
  background:#fafafa;
  border:1px solid #eee;
  border-radius:12px;
  padding:12px;
  min-height: 64px;
  font-size: 16px;
  color: #000; /* <-- add this */
}
    footer { margin-top: 14px; font-size: 12px; color:#000; text-align:center; }
    #debug { margin: 10px 0; font: 12px/1.3 -apple-system,BlinkMacSystemFont,sans-serif; color:#777; }
    .pill { background:#222; color:#fff; padding:3px 8px; border-radius:999px; font-size:12px; margin-left:6px; }
  </style>
</head>
<body>
  <h1>Cockney Translator</h1>
  <div id="debug">Loading…</div>
  <p class="hint">Type your English sentence. Pick a rhyming variant when prompted.</p>

  <textarea id="inputText" rows="4" placeholder="Type English here…"></textarea>
  <div class="row">
    <button class="btn" id="translateBtn">Translate</button>
    <button class="btn" id="sampleBtn" title="Try a sample">Sample</button>
  </div>

  <div id="variantPanel" class="panel" hidden>
    <strong>Pick your slang variants</strong>
    <div id="choices"></div>
  </div>

  <div class="panel">
    <strong>Output</strong>
    <div id="output" class="output"></div>
  </div>

  <footer>© bencockney.rocks</footer>

  <script>
    // ===== CONFIG: update if your backend URL changes =====
    const API_ORDER = [
      "https://cockney-agent-2.onrender.com/api/slang_index",     // best: normalized keys
      "https://cockney-agent-2.onrender.com/api/slang_variants",  // arrays
      "https://cockney-agent-2.onrender.com/api/slang"            // single phrases
    ];

    // ===== STATE =====
    let indexMap = {};     // normalizedMeaning -> [variants]
    let selectionMap = {}; // normalizedMeaning -> chosen variant

    // ===== DOM =====
    const $ = (id) => document.getElementById(id);
    const INPUT = $("inputText");
    const BTN   = $("translateBtn");
    const PANEL = $("variantPanel");
    const CHOICES = $("choices");
    const OUT   = $("output");
    const DEBUG = $("debug");

    const setDebug = (msg) => { DEBUG.innerHTML = msg; console.log("[debug]", msg.replace(/<[^>]*>/g,'')); };

    // ===== NORMALIZATION HELPERS =====
    const stripOuterQuotes = (s) => String(s).replace(/^[\'\"\s]+|[\'\"\s]+$/g, "");
    function normalizeMeaningKey(s) {
      let w = String(s).toLowerCase();
      w = w.replace(/\(.*?\)/g, " ");           // (notes) -> ''
      w = w.replace(/^(the|a|an)\s+/, "");      // 'the wife' -> 'wife'
      w = w.replace(/[^a-z'\s]/g, " ");         // drop punctuation
      w = w.replace(/\s+/g, " ").trim();
      w = w.replace(/'s$/, "");                 // wife's -> wife
      if (w.endsWith("ies")) w = w.slice(0,-3)+"y";
      else if (w.endsWith("es")) w = w.slice(0,-2);
      else if (w.endsWith("s")) w = w.slice(0,-1);
      return w;
    }
    const normalizeToken = (tok) => normalizeMeaningKey(String(tok).toLowerCase().replace(/[^a-z'\s]/g,""));
    const tokenize = (text) => String(text).split(/(\b)/);
    const splitParts = (meaning) =>
      String(meaning).split(/[,;/]|(?:\s+or\s+)/gi).map(stripOuterQuotes).filter(Boolean);

    // ===== LOAD & INDEX =====
    async function loadIndex() {
      // Try endpoints in order, cache-busting each time
      let raw, used = null;
      for (const url of API_ORDER) {
        try {
          const r = await fetch(url + "?t=" + Date.now(), { cache: "no-store" });
          if (r.ok) { raw = await r.json(); used = url; break; }
        } catch (e) {}
      }
      if (!raw) { setDebug("Failed to load API. Using aliases only."); raw = {}; }

      // Convert raw into a normalized index of arrays
      let asArrays = {};
      for (const [meaning, val] of Object.entries(raw)) {
        if (Array.isArray(val)) {
          asArrays[meaning] = val;
        } else {
          const phrase = String(val || "");
          const parts = phrase.split(/\s+/).filter(Boolean);
          const short = parts.length > 1 ? parts.slice(0, -1).join(" ") : phrase;
          asArrays[meaning] = (short && short !== phrase) ? [phrase, short] : [phrase];
        }
      }

      indexMap = {};
      let added = 0;
      for (const [meaning, arr] of Object.entries(asArrays)) {
        const parts = splitParts(meaning);
        const keys = parts.length ? parts : [meaning];
        keys.forEach(k => {
          const norm = normalizeMeaningKey(k);
          if (norm && !indexMap[norm]) { indexMap[norm] = arr; added++; }
        });
      }

      // Safety-net aliases for common words
      const aliases = {
        stairs: ["apples and pears","apples"],
        wife:   ["trouble and strife","trouble"],
        phone:  ["dog and bone","dog"],
        money:  ["bees and honey","bees"],
        tea:    ["Rosie Lee","Rosie"],
        head:   ["loaf of bread","loaf"],
        feet:   ["plates of meat","plates"],
        look:   ["butcher's hook","butcher's"]
      };
      for (const [k,v] of Object.entries(aliases)) if (!indexMap[k]) indexMap[k] = v;

      const rawCount = Object.keys(raw).length;
      const idxCount = Object.keys(indexMap).length;
      const which = used ? used.split("/api/")[1] : "aliases";
      setDebug(`Loaded <span class="pill">${rawCount}</span> via <b>${which}</b> | Indexed <span class="pill">${idxCount}</span> meanings`);
    }

    // ===== MATCH / UI =====
    function getVariantsForToken(tok) {
      const norm = normalizeToken(tok);
      if (norm && indexMap[norm]) return indexMap[norm];
      if (indexMap[norm + "s"]) return indexMap[norm + "s"];                         // plural fallback
      if (norm.endsWith("y") && indexMap[norm.slice(0,-1) + "ies"]) return indexMap[norm.slice(0,-1) + "ies"]; // y/ies fallback
      return null;
    }

    function buildChoices(tokens) {
      CHOICES.innerHTML = "";
      const seen = new Set();
      const matches = [];

      tokens.forEach((t) => {
        const v = getVariantsForToken(t);
        const key = normalizeToken(t);
        if (v && key && !seen.has(key)) { seen.add(key); matches.push({ meaning: key, variants: v }); }
      });

      PANEL.hidden = matches.length === 0;

      matches.forEach(({ meaning, variants }) => {
        const row = document.createElement("div");
        row.className = "choice";

        const left = document.createElement("div");
        left.style.display = "flex";
        left.style.flexDirection = "column";
        const label = document.createElement("label");
        label.textContent = meaning;
        const note = document.createElement("small");
        note.textContent = "choose a rhyme";
        left.appendChild(label); left.appendChild(note);

        const select = document.createElement("select");
        variants.forEach(v => {
          const opt = document.createElement("option");
          opt.value = v; opt.textContent = v; select.appendChild(opt);
        });
        if (selectionMap[meaning]) select.value = selectionMap[meaning];
        else selectionMap[meaning] = variants[0];
        select.addEventListener("change", () => { selectionMap[meaning] = select.value; renderOutput(); });

        row.appendChild(left);
        row.appendChild(select);
        CHOICES.appendChild(row);
      });
    }

    function preserveCase(originalToken, replacement) {
      const m = originalToken.match(/[A-Za-z']+/);
      if (!m) return replacement;
      return m[0][0] === m[0][0].toUpperCase()
        ? replacement.charAt(0).toUpperCase() + replacement.slice(1)
        : replacement;
    }

    // Expose this globally so it’s always callable
    window.renderOutput = function renderOutput() {
      const tokens = tokenize(INPUT.value);
      const out = tokens.map(tok => {
        const v = getVariantsForToken(tok);
        if (v) {
          const key = normalizeToken(tok);
          const chosen = selectionMap[key] || v[0];
          return preserveCase(tok, chosen);
        }
        return tok;
      }).join("");
      OUT.textContent = out;
    };

    function recompute() {
      const tokens = tokenize(INPUT.value);
      buildChoices(tokens);
      renderOutput();
    }

    // ===== INIT =====
    (async function init(){
      await loadIndex();
      INPUT.addEventListener("input",  recompute);
      BTN.addEventListener("click",    recompute);
      const SAMPLE = document.getElementById("sampleBtn");
      if (SAMPLE) SAMPLE.addEventListener("click", () => {
        INPUT.value = "I ran up the stairs and called my wife on the phone about the money.";
        recompute();
      });
      recompute();
    })();
  </script>
</body>
</html>
